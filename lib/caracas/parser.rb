# This script represents a way for parsing schema by exposing a simple iterator based API.
# Iterator Parser is faster and uses less memory than a Model based parser.

module Caracas

  # Extension of the class for iterator based schema parsing.
  class Schema

    # Entry point for schema parsing.
    #
    # @param parser [Parser::InstanceMethods] the parser, usualy generated by {Parser::Factory#build}
    #
    # @example
    #   sch = Caracas.schema 'Demo' do ... end
    #   model = sch.parse Caracas::Parser::HashModeler.new
    #
    # @return [Object] a value returned by {Parser::InstanceMethods#end_schema}
    def parse(parser)
      @parser = parser
      @parser.context.schema_name = name
      @parser.start_schema
      self.instance_eval(&self.lambda)
      @parser.end_schema
    end

    def table(name, opts={}, &block)
      fire_element_event(:start, :table, [name])
      self.instance_eval(&block) if block_given?
      fire_element_event(:end, :table, [name])
    end
    def desc(value)
      fire_element_event(:start, :desc, [value])
      fire_element_event(:end, :desc, [value])
    end
    def column(name, type, opts={}, &block)
      fire_element_event(:start, :column, [name, type, opts])
      self.instance_eval(&block) if block_given?
      fire_element_event(:end, :column, [name, type, opts])
    end
    def fk(colname, desttable, opts={}, &block)
      fire_element_event(:start, :fk, [colname, desttable, opts])
      self.instance_eval(&block) if block_given?
      fire_element_event(:end, :fk, [colname, desttable, opts])
    end
    def tags(names, &block)
      fire_element_event(:start, :tags, [names])
      self.instance_eval(&block) if block_given?
      fire_element_event(:end, :tags, [names])
    end
    def graphviz(text)
      fire_element_event(:start, :graphviz, [text])
      fire_element_event(:end, :graphviz, [text])
    end

    private

    def fire_element_event(action, el, args)
      @parser.context.event = Caracas::Parser::Event.new(el, action, args)
      if :start == action
        @parser.start_element
      else
        @parser.end_element
      end
    end
  end


  module Parser

    # Structure representing an event in parsing.
    Event = Struct.new(:element, :action, :args)

    # A context of the parsing, can by used for a generic purpose.
    # Instance of the class is a singleton in the running parsing
    # and is accessible by {InstanceMethods#context}
    class Context < Hash
      # Accessor for last {Event} fired in parsing.
      attr_accessor :event
      # Accessor for the schema name.
      attr_accessor :schema_name
    end

    # This module represents an interface to be implemented by each parser.
    module InstanceMethods
      def start_schema
        # blah
      end
      def end_schema
        raise 'subclass must implement to return a value', NotImplementedError
      end
      def start_element
        # blah
      end
      def end_element
        # blah
      end
      def context
        @ctx ||= Context.new
      end
    end

    # Factory class to build parser classes.
    class Factory

      # Factory method for a new parser class.
      #
      # @yield block with the parsing logic
      #
      # @return [Class] a new class usable in {Schema#parse}
      def self.build(&block)
        raise ArgumentError, 'block required!' unless block_given?

        Class.new do
          include InstanceMethods
          class_eval(&block)
        end
      end

    end

  end # Parser
end # Caracas
